#lang planet neil/sicp
(#%require r5rs/init)
(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))
(define (fold-right op initial sequence)
  (if (null? sequence)
      initial
      (op 
       (car sequence)
       (fold-right op initial (cdr sequence)))))

(define (reverse2 sequence)
  (fold-left (lambda (x y)
                (append (list y) x))
              '()
              sequence))
(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))
(define (enumerate-interval low high)
  (if (> low high)
      nil
      (cons low (enumerate-interval (+ 1 low) high))))

(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))))
         (else (filter predicate (cdr sequence)))))
(define (permutations s)
  (if (null? s)
      (list nil)
      (flatmap (lambda (x)
                 (map (lambda (p) (cons x p))
                      (permutations (remove x s))))
               s)))
(define (remove item sequence)
  (filter (lambda (x) (not (= x item)))
          sequence))
(define (unique-pairs n)
  (flatmap (lambda (i)
             (map (lambda (j) (list i j))
                  (enumerate-interval 1 (- i 1))))
           (enumerate-interval 1 n)))
; -------- <prime?> --------
(define (prime? n)
  (= n (smallest-divisor n)))
;
(define (smallest-divisor n)
  (find-divisor n 2))
;
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
;
(define (divides? a b)
  (= (remainder b a) 0))
; -------- </prime?> --------

(define (prime-sum? pair)
  (prime? (+ (car pair) (cadr pair))))

(define (make-pair-sum pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))

(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum?
               (unique-pairs n))))
(define (square x) (* x x))
(define (unique-triples n)
  (flatmap (lambda (i)
             (flatmap (lambda (j)
                      (map (lambda (k) (list i j k))
                             (enumerate-interval 1 (- j 1))))
                      (enumerate-interval 2 (- i 1))))
           (enumerate-interval 1 n)))
(define (equal-sum? s)
  (lambda (triple)
    (= s (+ (car triple) (cadr triple) (caddr triple)))))
(define (make-triple-sum triple)
  (list (car triple) (cadr triple) (caddr triple)
        (+ (car triple) (cadr triple) (caddr triple))))
(define (equal-sum-triples n s)
  (map make-triple-sum
       (filter (equal-sum? s)
               (unique-triples n))))
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (position) (safe? k position))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))
(define empty-board '())
(define (adjoin-position row k rest-of-queens)
  (append rest-of-queens (list (list row k))))
(define (safe? k positions)
  (define (two-queens-safe? q1 q2)
    (and (not (= (car q1) (car q2)))
         (not (= (- (car q1) (cadr q1))
                 (- (car q2) (cadr q2))))
         (not (= (+ (car q1) (cadr q1))
                 (+ (car q2) (cadr q2))))))

  (let ((new-queen (last positions)))
    (define (check i positions)
      (cond ((= i k) true)
            ((two-queens-safe? (car positions) new-queen) 
             (check (+ i 1) (cdr positions)))
            (else false)))
    (check 1 positions)))
(define (last items)
  (if (null? (cdr items))
      (car items)
      (last (cdr items))))
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        ((sum? exp) (make-sum (deriv (addend exp) var)
                              (deriv (augend exp) var)))

        ((product? exp)
         (make-sum
          (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
          (make-product (deriv (multiplier exp) var)
                        (multiplicand exp))))

        (else
          (error "unknown expression type: DERIV" exp))))
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
(define (make-sum a1 a2) (list '+ a1 a2))

(define (make-product m1 m2) (list '* m1 m2))
(define (sum? x) (and (pair? x) (eq? (car x) '+)))
(define (addend s) (cadr s))
(define (augend s) (caddr s))
(define (product? x) (and (pair? x) (eq? (car x) '*)))

(define (multiplier p) (cadr p))
(define (multiplicand p) (caddr p))
(define (install-deriv-package)
  (define (=number? exp num)
    (and (number? exp) (= exp num))) 

  ; sum
  (define (make-sum a1 a2)
    (cond ((=number? a1 0) a2)
          ((=number? a2 0) a1)
          ((and (number? a1) (number? a2)) (+ a1 a2))
          (else (list '+ a1 a2))))
  (define (addend opds) (car opds))
  (define (augend opds) (cadr opds))
  (define (deriv-sum opds var)
    (make-sum (deriv (addend opds) var)
              (deriv (augend opds) var)))

  ; product
  (define (make-product m1 m2)
    (cond ((or (=number? m1 0) (=number? m2 0)) 0)
          ((=number? m1 1) m2)
          ((=number? m2 1) m1)
          ((and (number? m1) (number? m2)) (* m1 m2))
          (else (list '* m1 m2))))
  (define (multiplier opds) (car opds))
  (define (multiplicand opds) (cadr opds))
  (define (deriv-product opds var) 
    (make-sum 
     (make-product (multiplier opds)
                   (deriv (multiplicand opds) var))
     (make-product (deriv (multiplier opds) var)
                   (multiplicand opds))))

  ; exponentiation
  (define (make-exponentiation base exp)
    (cond ((=number? exp 0) 1)
          ((=number? exp 1) base)
          (else (list '** base exp))))
  (define (base opds) (car opds))
  (define (exponent opds) (cadr opds))
  (define (deriv-exponentation opds var)
    (make-product
     (exponent opds)
     (make-product
      (make-exponentiation (base opds)
                           (make-sum (exponent opds) (- 1)))
      (deriv (base opds) var))))

  ;; interface
  (put 'deriv '+ deriv-sum)
  (put 'deriv '* deriv-product)
  (put 'deriv '** deriv-exponentation) 
  'done)
(define get 2d-get)
(define put 2d-put!)

(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))
(define (deriv exp var)
   (cond ((number? exp) 0)
         ((variable? exp) (if (same-variable? exp var) 1 0))
         (else ((get 'deriv (operator exp)) (operands exp)
                                            var))))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))